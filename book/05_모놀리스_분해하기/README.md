# CHAPTER 5. 모놀리스 분해하기

모놀리스(모놀리식) 시스템은 시간이 흐르면서 자라나고,  빠른 속도로 새로운 기능과 코드 라인을 요구하며, 머지않아 조직 내 사람들이 건드리거나 바꾸기를 두려워하는 거대하고 무서운 존재가 된다.

어떻게하면 한번에 엄청난 분량의 코드를 재작성하지 않고 이러한 모놀리식 애플리케이션의 분해를 시작할 수 있을까?



## 5.1 접합부가 중요하다

우리는 응집력이 높고 느슨히 결합되는 서비스를 원한다. 하지만 모놀리스의 문제는 이와는 너무 정반대라는 것이다. 응집력을 지향하며 함께 변경될 가능성이 높은 것들을 함께 두기 보다는 관련 없는 모든 종류의 코드를 가져와 서로 붙여놓는다.

접합부는 '코드베이스의 나머지 부분에 영향을 주지않는 격리된 코드 부분'이라고 정의한다. 그리고 경계가 있는 콘텍스트(bounded context)는 훌륭한 접합부를 만든다. 경계가 있는 콘텍스트의 정의가 조직 내의 응집력 있고 느슨히 결합된 경계를 잘 표현하기 때문이다.



## 5.2 뮤직코퍼레이션 분해하기

뮤직코퍼레이션 온라인 시스템이 아주 거대한 모놀리식 서비스 백엔드라고 가정하자. 그리고 이 모놀리식 백엔드 서비스가 포함하고 있다고 생각되는 4개의 콘텍스트는 다음과 같다.

- 제품 목록
  - 판매하는 제품에 대한 모든 메타데이터
- 재무
  - 계정, 결제, 환불
- 창고
  - 고객 주문 발송 및 반품, 재고 수준 관리
- 추천



처음 해야 할 일은 이 콘텍스트들을 대표하는 패키지를 생성해서 기존 코드를 이동시키는 것이다. 작은 코드베이스의 경우 반나절로 충분하지만, 수백만 라인의 코드를 처리하는 데는 수주 또는 수개월이 걸릴 수 있다.



## 5.3 모놀리스를 분리하는 이유

시스템을 조금씩 깎아내리듯 분리하는 것이 좋다. 이러한 점진적 접근법을 통해 마이크로서비스를 더 잘 배울 수 있으며, 무언가 잘못된 경우 피해를 줄일 수 있다.



### 5.3.1 변경의 속도

접합부가 마이크로서비스로 분리된다면 독립된 자율적 개체가 되어 더욱 신속하게 변경 가능하다.



### 5.3.2 팀 구조

이 아이디어에 대해서는 10장에서 더 자세히 다룬다.



### 5.3.3 보안

서비스를 분리한다면 개별 서비스를 모니터링할 수 있고 데이터의 전송과 저장에 있어 추가적인 보호를 할 수 있다. (9장에서 더 자세히 다룬다.)



### 5.3.4 기술

코드를 분리해서 독립된 서비스로 만들 수 있다면 기능에 특화된 기술 사용을 쉽게 고려할 수 있다.



## 5.4 뒤엉킨 의존성

분리할 접합부 몇 개를 인식했을 때 고려할 또 다른 점은 그 코드가 시스템 나머지 부분과 어떻게 엉켜져 있는가 하는 것이다.

대부분 뒤엉킨 의존성의 출처는 데이터베이스이다.



## 5.6 문제에 대처하기

첫 번째 단계는 코드 자체를 살펴보고, 데이터베이스에 읽고 쓰는 코드 부분을 보는 것이다. 바운디드 콘텍스트를 바탕으로 코드를 패키지로 그룹화했다면, 데이터베이스에 접근하는 코드도 같은 방식을 적용하는 것이다. 콘텍스트에 따라 데이터베이스에 접근하는 코드를 해당 패키지에 여러 부분으로 분리하느 것이다.

하지만 이것이 전부는 아니다. 데이터베이스상에서 같은 테이블이 다수의 경계가 다른 콘텍스트에 사용되는 경우에는 어떻게 할 것인가?



## 5.7 예: 외부 키 관계 깨뜨리기

1. 외부키 사용을 중단한다.
2. 외부키 사용이 필요했던 부분을 별도 API를 통해 제공한다.

물론, 이 과정에서 네트워크를 통한 추가적인 통신이 필요하다. 성능적인 저하가 발생할 수 있으나 수용가능한 상태라면 크게 문제되지 않는다.



## 5.8 예: 공유 정적 데이터

여러 서비스들에서 공유해 사용하는 데이터를 데이터베이스에 저장해 사용하는 사례는 흔하게 볼 수 있다.

대부분의 상황에서는 단순한 정적 데이터를 다루는 케이스이기 때문에 각 서비스 별로 분리해서 데이터를 다룰 수 있도록 별도의 설정 파일로 다루거나 코드에 직접 삽입하는 방식을 추천한다. (데이터 일관성에 대한 문제는 존재하지만 합리적인 접근 방법이라고 생각한다.)



## 5.9 예: 공유 데이터

변경 가능한 공유 데이터는 시스템을 분리하려 할 때 자주 발생하는 문제가 될 수 있다.

이때는 누락된 도메인 개념이 있을 가능성이 높다. 공유 데이터를 추상화된 도메인으로 뽑아내어 적절한 서비스에 위치시키고 API를 사용해 변경가능하도록 해야한다.



## 5.11 데이터베이스 리팩토링

### 5.11.1 단계적인 분리

애플리케이션 코드를 완전히 분리하여 각각의 마이크로서비스로 만들기 전에, 서비스는 이전과 같이 하나로 유지한 채 우선 스키마를 분리하는 것을 추천한다.

스키마가 분리되면 단일 작업을 수행하는 데이터베이스의 호출 횟수가 증가할 수 있다. 이전에는 하나의 select 문을 통해 필요한 데이터를 모두 추출할 수 있었지만, 지금은 두 개의 테이블에서 추출해서 메모리 상에서 조인을 수행해야 할 필요가 있다. 또한 두 개의 스키마로 분리하면 트랜잭션 일관성을 깨뜨리게 된다.

애플리케이션 코드를 그대로 유지한 채 스키마만 분리하면 변경한 것을 되돌리거나 서비스의 소비자에게 영향을 주지 않고 작은 변경을 계속할 수 있다. DB 분리가 적절하고 만족스럽다면 이제 애플리케이션 코드를 두 개의 서비스로 분리하는 것을 고려한다.



## 5.12 트랜잭션의 경계

모놀리식 스키마의 경우 아마도 모든 생성과 업데이트는 단일 트랜잭션 경계 내에서 수행될 것이다. 따라서 데이터베이스를 분리할 경우 단일 트랜잭션에 의해 제공된 안정성을 잃는다.

서비스 별로 스키마를 분리하고 문제가 발생하는 경우 어떻게 해야할까?



### 5.12.1 나중에 재시도하기

실패한 연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도 할 수 있다. 이것은 최종적 일관성(eventual consistency)의 또 다른 형태이다. 트랜잭션이 완료되어을 때 시스템이 일관성을 유지하는 상태임을 보장하기 위해 트랜잭션 경계를 사용하는 대신 향후 특정 시점에 시스템이 스스로 일관성을 유지하는 상태가 될 수 있음을 허용한다.



### 5.12.2 전체 작업 중지하기

다른 방안은 시스템을 다시 일관성이 유지된 상태로 복귀할 수 있도록 전체 작업을 중지하는 것이다. 보상 트랜잭션을 발행하는 것으로 직전의 완료된 트랜잭션을 되돌릴 새로운 트랜잭션을 발행시키는 것이다.

만약 보상 트랜잭션도 실패하면 어떻게 될까? 이런 상황에서는 보상 트랜잭션을 재시도하거나 일관성이 유지되지 않는 것을 정리하는 백엔드 프로세스를 수행할 필요가 있다. 이는 관리자가 접근할 수 있는 관리 스크린 또는 자동화된 프로세스처럼 단순화 할 수 있다.



### 5.12.3 분산 트랜잭션

보상 트랜잭션을 수동으로 통제하는 방식의 대안은 분산 트랜잭션의 사용이다. 분산 트랜잭션은 하부 시스템에서 수행되는 다양한 트랜잭션을 통제하기 위해 트랜잭션 관리자라는 전체적인 통제 프로세스를 사용해서 트랜잭션 내부의 여러 트랜잭션을 확장하려 시도한다.

> 분산 트랜잭션을 처리하는 가장 범용적인 알고리즘은 2단계 커밋을 사용하는 것이다. 그러나 복잡성이 증가한다.



### 5.12.4 그렇다면 무엇을 해야 할까?

이러한 솔루션들은 복잡성을 증가시킨다. 분산 트랜잭션을 제대로 수행하는 것은 쉽지 않으며 실제로 확장성을 저해할 수 있다. 재시도 보상 로직을 최종 방법으로 사용하는 시스템들은 추론하기 더 어려우며 데이터의 불일치를 고치기 위해 다른 보상 행위가 필요할 수 있다.

단일 트랜잭션 내에서 발생하는 비즈니스 연산을 접하게 되면 그것이 정말 필요한 것인지 자문해보아야 한다. 비즈니스 연산이 서로 다른 지역의 트랜잭션에서 발생하고 최종적인 일관성의 개념에 의존할 수 있다면 이러한 시스템은 구축하고 확장하기가 훨씬 용이하다. (11장에서 자세히 다룬다.)



## 5.13 리포팅

## 5.14 리포팅 데이터베이스

리포팅은 유용한 결과를 생성하기 위해 조직 내 여러 부분의 데이터를 함께 모을 필요가 있다.

일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장된다. 이는 모든 데이터가 한 곳에 모여 있어서 모든 정보의 경계를 넘어 리포팅하는 것이 실제로 매우 쉽다는 것을 의미한다. 그러나 몇 가지 단점도 존재한다.

- 데이터베이스 스키마는 실행 중인 모놀리식 서비스와 리포팅 시스템 사이에서 사실상 공유되는 것이다. -> 스키마의 변경을 어렵게 만든다.
- 실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적화하는 방법이 제한적이다.



## 5.15 서비스 호출을 통한 데이터 추출

다양한 해결 방법이 있지만, 모두 원본 시스템으로부터 API를 통해 데이터 추출에 의존한다.

리포팅을 쉽게 만들기 위해서는 서비스에 사용되는 API를 그대로 사용하는 것이 아닌 별도의 배치 API를 제공하는 것이 좋다.



## 5.16 데이터 펌프

리포팅 시스템이 데이터를 끌어오는 방식 대신 리포팅 시스템에 데이터를 밀어 넣는 방식을 시도할 수 있다.

데이터 펌프를 시작하려면 해당 서비스를 관리하는 팀이 그것을 개발하고 관리해야 한다. (각 마이크로 서비스의 스키마를 모아와 하나의 모놀리식 스키마를 만드는 것과 같은 방식)



## 5.17 이벤트 데이터 펌프

마이크로서비스에서 관리하는 개체의 상태가 변경될 때 발생하는 이벤트를 구독해서 리포팅 데이터베이스로 데이처를 밀어넣는 방식도 가능하다. 그럼 원본 마이크로서비스의 하부 데이터베이스와 결합되지 않는다. 대신 해당 서비스에 의해 발행된 이벤트와 바인딩된다.

이벤트가 발생할 때 리포팅 시스템에 데이터를 보낼 수 있으므로 정기적으로 데이터를 밀어 넣는 것보다 더 신속하게 데이터가 리포팅 시스템에 흘러들어갈 수 있다.

이 방법의 단점은 필요한 모든 저오를 이벤트로 발행해야 하는 것이다.